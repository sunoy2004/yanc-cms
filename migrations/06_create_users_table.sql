-- Create users table for authentication and profile storage
CREATE TABLE IF NOT EXISTS users (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  -- If you use Supabase Auth, link the auth user id here for RLS checks
  auth_id UUID UNIQUE,
  username TEXT NOT NULL UNIQUE,
  email TEXT,
  name TEXT,
  password_hash TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Trigger to update updated_at on row change
CREATE OR REPLACE FUNCTION trigger_set_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS set_updated_at ON users;
CREATE TRIGGER set_updated_at
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE PROCEDURE trigger_set_updated_at();

-- Insert a default admin user if not exists (password will be placeholder â€” instruct to reset)
-- NOTE: Replace the password_hash value with a bcrypt hash if desired.
INSERT INTO users (username, email, name)
SELECT 'admin', 'admin@yanc.in', 'Admin User'
WHERE NOT EXISTS (SELECT 1 FROM users WHERE username = 'admin');

-- Enable Row Level Security (RLS) and add policies
ALTER TABLE users ENABLE ROW LEVEL SECURITY;

-- Allow authenticated users (via Supabase Auth) to SELECT their own profile
CREATE POLICY "Allow authenticated select own" ON users
  FOR SELECT
  USING (auth.uid() = auth_id);

-- Allow authenticated users to INSERT their own row (client-side signup flows)
CREATE POLICY "Allow authenticated insert own" ON users
  FOR INSERT
  WITH CHECK (auth.uid() = auth_id);

-- Allow authenticated users to UPDATE their own row
CREATE POLICY "Allow authenticated update own" ON users
  FOR UPDATE
  USING (auth.uid() = auth_id)
  WITH CHECK (auth.uid() = auth_id);

-- Note: service_role key bypasses RLS so server-side operations will continue to work.

